create extension if not exists "pgjwt" with schema "extensions";

create extension if not exists "vector" with schema "public";

revoke delete on table "public"."credits" from "anon";

revoke insert on table "public"."credits" from "anon";

revoke references on table "public"."credits" from "anon";

revoke select on table "public"."credits" from "anon";

revoke trigger on table "public"."credits" from "anon";

revoke truncate on table "public"."credits" from "anon";

revoke update on table "public"."credits" from "anon";

revoke delete on table "public"."credits" from "authenticated";

revoke insert on table "public"."credits" from "authenticated";

revoke references on table "public"."credits" from "authenticated";

revoke select on table "public"."credits" from "authenticated";

revoke trigger on table "public"."credits" from "authenticated";

revoke truncate on table "public"."credits" from "authenticated";

revoke update on table "public"."credits" from "authenticated";

revoke delete on table "public"."credits" from "service_role";

revoke insert on table "public"."credits" from "service_role";

revoke references on table "public"."credits" from "service_role";

revoke select on table "public"."credits" from "service_role";

revoke trigger on table "public"."credits" from "service_role";

revoke truncate on table "public"."credits" from "service_role";

revoke update on table "public"."credits" from "service_role";

revoke delete on table "public"."payment_notifications" from "anon";

revoke insert on table "public"."payment_notifications" from "anon";

revoke references on table "public"."payment_notifications" from "anon";

revoke select on table "public"."payment_notifications" from "anon";

revoke trigger on table "public"."payment_notifications" from "anon";

revoke truncate on table "public"."payment_notifications" from "anon";

revoke update on table "public"."payment_notifications" from "anon";

revoke delete on table "public"."payment_notifications" from "authenticated";

revoke insert on table "public"."payment_notifications" from "authenticated";

revoke references on table "public"."payment_notifications" from "authenticated";

revoke select on table "public"."payment_notifications" from "authenticated";

revoke trigger on table "public"."payment_notifications" from "authenticated";

revoke truncate on table "public"."payment_notifications" from "authenticated";

revoke update on table "public"."payment_notifications" from "authenticated";

revoke delete on table "public"."payment_notifications" from "service_role";

revoke insert on table "public"."payment_notifications" from "service_role";

revoke references on table "public"."payment_notifications" from "service_role";

revoke select on table "public"."payment_notifications" from "service_role";

revoke trigger on table "public"."payment_notifications" from "service_role";

revoke truncate on table "public"."payment_notifications" from "service_role";

revoke update on table "public"."payment_notifications" from "service_role";

alter table "public"."credits" drop constraint "credits_user_id_fkey";


  create table "public"."accounts" (
    "id" uuid not null default extensions.uuid_generate_v4(),
    "email" text not null,
    "name" text,
    "created_at" timestamp with time zone default now()
      );


alter table "public"."credits" alter column "credit_count" set default '0'::numeric;

alter table "public"."credits" alter column "credit_count" set data type numeric using "credit_count"::numeric;

alter table "public"."credits" alter column "id" drop default;

alter table "public"."credits" alter column "id" add generated by default as identity;

alter table "public"."credits" alter column "id" set data type bigint using "id"::bigint;

alter table "public"."credits" alter column "user_id" set not null;

CREATE UNIQUE INDEX accounts_email_key ON public.accounts USING btree (email);

CREATE UNIQUE INDEX accounts_pkey ON public.accounts USING btree (id);

alter table "public"."accounts" add constraint "accounts_pkey" PRIMARY KEY using index "accounts_pkey";

alter table "public"."accounts" add constraint "accounts_email_key" UNIQUE using index "accounts_email_key";

alter table "public"."credits" add constraint "credits_user_id_fkey" FOREIGN KEY (user_id) REFERENCES auth.users(id) not valid;

alter table "public"."credits" validate constraint "credits_user_id_fkey";

set check_function_bodies = off;

CREATE OR REPLACE FUNCTION public.create_user_account()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
BEGIN
  INSERT INTO public.accounts (id, email)
  VALUES (NEW.id, NEW.email);

  RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.match_knowledge_base(query_embedding vector, match_threshold double precision, match_count integer, account_id uuid)
 RETURNS TABLE(id uuid, question text, answer text, similarity double precision)
 LANGUAGE sql
 STABLE
AS $function$
  select
    kb.id,
    kb.question,
    kb.answer,
    1 - (kb.embedding <=> query_embedding) as similarity
  from knowledge_base kb
  where kb.account_id = match_knowledge_base.account_id
    and kb.embedding <=> query_embedding < 1 - match_threshold
  order by kb.embedding <=> query_embedding
  limit match_count;
$function$
;

CREATE OR REPLACE FUNCTION public.increment_credit(user_id_input uuid, increment_value integer)
 RETURNS void
 LANGUAGE plpgsql
AS $function$
BEGIN
  INSERT INTO credits (user_id, credit_count)
  VALUES (user_id_input, increment_value)
  ON CONFLICT (user_id)
  DO UPDATE SET credit_count = credits.credit_count + increment_value;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.on_new_payment_notification()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
  PERFORM net.http_post(
    url := 'https://mtnodjzbbmrmmsylhixj.supabase.co/functions/v1/notify-admin-telegram',
    body := jsonb_build_object('record', row_to_json(NEW)),
    headers := '{"Content-Type": "application/json"}'::jsonb
  );
  RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.prevent_credit_increase()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
declare
  jwt json;
  user_role text;
begin
  -- Read JWT claims if available
  begin
    jwt := current_setting('request.jwt.claims', true)::json;
    user_role := jwt->>'role';
  exception when others then
    -- No JWT means admin console or service context â†’ allow
    user_role := 'service_role';
  end;

  -- Block credit increase unless service role
  if user_role != 'service_role' and NEW.credit_count > OLD.credit_count then
    raise exception 'Cannot increase credit_count via update';
  end if;

  return NEW;
end;
$function$
;


  create policy "Allow update own credit"
  on "public"."credits"
  as permissive
  for update
  to authenticated
using ((auth.uid() = user_id))
with check ((auth.uid() = user_id));



  create policy "Enable read access for all users"
  on "public"."credits"
  as permissive
  for select
  to public
using (true);



